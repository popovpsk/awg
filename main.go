package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"regexp"
	"sort"
	"strings"

	"github.com/popovpsk/awg/future"
	"github.com/popovpsk/awg/types"
)

func main() {
	gofile := os.Getenv("GOFILE")
	if gofile == "" {
		handleError(fmt.Errorf("GOFILE is empty"))
	}
	out := strings.TrimSuffix(gofile, ".go") + "_awg.go"
	generate(gofile, out)
}

func generate(path string, out string) {
	fset := token.NewFileSet()
	astFile, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
	handleError(err)
	funcs := findFunctions(astFile.Decls)
	importSet := make(map[string]struct{})
	generatedFuns := make([]string, 0)
	for _, f := range funcs {
		jobs := findJobs(f)
		if len(jobs) > 0 {
			for _, j := range jobs {
				generatedFunc, imports := j(f)
				for i := range imports {
					importSet[imports[i]] = struct{}{}
				}
				generatedFuns = append(generatedFuns, generatedFunc)
			}
		}
	}
	pkg := astFile.Name.Name
	if len(generatedFuns) > 0 {
		writeResult(out, pkg, generatedFuns, getSortedImports(astFile.Imports, importSet))
	}
}

func writeResult(out string, pkg string, funcs, imports []string) {
	f := prepareFile(out)
	defer f.Close()

	b := bytes.NewBuffer(make([]byte, 0, 1024))
	writePkg(b, pkg)
	writeImports(b, imports)
	writeFuncs(b, funcs)
	b.WriteString("\n")
	formatted, err := format.Source(b.Bytes())
	handleError(err)
	f.Write(formatted)
}

func getSortedImports(imports []*ast.ImportSpec, importSet map[string]struct{}) []string {
	result := make([]string, 0, len(importSet))
	for _, ispec := range imports {
		if ispec.Name != nil {
			name := ispec.Name.Name
			if _, ok := importSet[name]; ok {
				result = append(result, fmt.Sprintf("%s %s", name, ispec.Path.Value))
			}
		} else {
			separated := strings.Split(ispec.Path.Value, "/")
			name := separated[len(separated)-1]
			name = strings.Trim(name, "\"")
			if _, ok := importSet[name]; ok {
				result = append(result, ispec.Path.Value)
			}
		}
	}
	sort.Strings(result)
	return result
}

func prepareFile(out string) *os.File {
	f, err := os.OpenFile(out, os.O_RDWR, os.ModePerm)
	if os.IsExist(err) {
		err = f.Truncate(0)
		handleError(err)
	} else {
		f, err = os.Create(out)
		handleError(err)
	}
	_, err = f.WriteString("// Code generated by awg. DO NOT EDIT.\n")
	handleError(err)
	return f
}

func writePkg(w io.StringWriter, pkg string) {
	_, err := w.WriteString(fmt.Sprintf("package %s\n\n", pkg))
	handleError(err)
}

func writeImports(w io.StringWriter, imports []string) {
	w.WriteString("import (\n")
	for i := range imports {
		w.WriteString(imports[i])
		w.WriteString("\n")
	}
	w.WriteString(")\n")
}

func writeFuncs(w io.StringWriter, funcs []string) {
	for i := range funcs {
		w.WriteString("\n\n")
		w.WriteString(funcs[i])
	}
}

func handleError(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

func findFunctions(decls []ast.Decl) []*ast.FuncDecl {
	result := make([]*ast.FuncDecl, 0)
	for _, d := range decls {
		if fdecl, ok := d.(*ast.FuncDecl); ok {
			result = append(result, fdecl)
		}
	}
	return result
}

func findJobs(f *ast.FuncDecl) []generator {
	result := make([]generator, 0)
	exp := regexp.MustCompile(`awg:.+\n`)
	text := f.Doc.Text()
	match := exp.FindString(text)
	if len(match) == 0 {
		return result
	}
	tags := strings.Split(match, " ")
	for i := range tags {
		tags[i] = strings.TrimSpace(tags[i])
	}
	for _, t := range tags[1:] {
		if !validateTag(t) {
			log.Println("invalid tag", t)
			continue
		}
		result = append(result, tagsMap[t])
	}
	return result
}

var tagsMap = map[string]generator{
	"future": generateFuture,
}

func validateTag(tag string) bool {
	_, ok := tagsMap[tag]
	return ok
}

type generator func(decl *ast.FuncDecl) (string, []string)

func generateFuture(decl *ast.FuncDecl) (string, []string) {
	methodName := decl.Name.String()
	imports := make([]string, 0)
	params := getParams(decl.Type.Params, &imports)
	result := getParams(decl.Type.Results, &imports)
	recvParams := getParams(decl.Recv, &imports)
	var recv *types.Variable
	if len(recvParams) > 0 {
		recv = &types.Variable{Name: recvParams[0].Name, T: recvParams[0].T}
	}
	f := &future.Future{
		Params:  params,
		Results: result,
		Recv:    recv,
		Name:    methodName,
	}
	return f.GenerateFunc(), imports
}

func getParams(fieldList *ast.FieldList, imports *[]string) []types.Variable {
	if fieldList == nil || len(fieldList.List) == 0 {
		return nil
	}
	result := make([]types.Variable, 0, len(fieldList.List))
	for _, f := range fieldList.List {
		v := types.Variable{}
		if len(f.Names) > 0 {
			v.Name = f.Names[0].Name
		}
		v.T = getTypeStr(f.Type, imports)
		result = append(result, v)
	}
	return result
}

func getTypeStr(t ast.Expr, imports *[]string) string {
	switch t.(type) {
	case *ast.StarExpr:
		return "*" + getExprName(t.(*ast.StarExpr).X, imports)
	case *ast.ArrayType:
		return "[]" + getTypeStr(t.(*ast.ArrayType).Elt, imports)
	case *ast.MapType:
		m := t.(*ast.MapType)
		key := getTypeStr(m.Key, imports)
		value := getTypeStr(m.Value, imports)
		return fmt.Sprintf("map[%s]%s", key, value)
	case *ast.InterfaceType:
		return "interface{}"
	case ast.Expr:
		return getExprName(t, imports)
	default:
		panic("undefined type token")
	}
}

func getExprName(t ast.Expr, imports *[]string) string {
	switch t.(type) {
	case *ast.Ident:
		return t.(*ast.Ident).Name
	case *ast.SelectorExpr:
		return getSelectorExprName(t, imports)
	default:
		panic("undefined type token")
	}
}

func getSelectorExprName(t ast.Expr, imports *[]string) string {
	se := t.(*ast.SelectorExpr)
	importName := se.X.(*ast.Ident).Name
	*imports = append(*imports, importName)
	return importName + "." + se.Sel.Name
}
